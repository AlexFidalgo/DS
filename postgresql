---------------------------------------------- COURSE 1 ----------------------------------------------

POSTGRESQL DOWNLOAD
/etc/apt/sources.list.d/pgdg.list

BASIC COMMANDS
   Acessar o postgresql (connecting to the server): psql -Upostgres -hlocalhost
Mostrar base de dados (starting a postgres server instance): \l
Sair do postgres=# (gets out of the session)(super user prompt, # indicates you are the superuser): \q
Sair do postgres@alex-Inspiron-5423:/home/alex$: exit (postgres is the super user)
psql is a client that we run locally
$ indica que temos um usuário normal; # é o administrador do sistema
Os comandos são, em geral, em letras minúsculas. Muitos deles aceitam argumentos. Os argumentos que começam com um (ou dois) “-” são opcionais.
O pipe (|) é usado para fazer encadeamento de processos, ou seja, faz com que a saída de um comando seja enviada como entrada para o próximo comando.
O > direciona a saída de um comando para um arquivo ou dispositivo.
O >>, assim como o >, também direciona a saída de um comando para um arquivo, a diferença é que ele não substitui o conteúdo do arquivo, mas acrescenta ao final.
Name: postgres, template0, template1 are native databases, we better not touch them
Show tabled: \dt

CREATING A USER AND DATABASE
postgres=# CREATE USER pg4e WITH PASSWORD 'secret';
postgres=# CREATE DATABASE people WITH OWNER 'pg4e';
Now in the database server, we have a new empty database and I have access credentials that I can get into that (the SQL client can now talk to the database)

CONNECTING TO THE DATABASE
~$ psql people pg4e -hlocalhost
people=> this is not a super user prompt
people=> \dt shows the tables inside the database people

CREATING A TABLE
people=> CREATE TABLE users(name VARCHAR(128), email VARCHAR(128));
people=> \d+ users shows the schema of the users table

WORKING WITH TABLES
INSERT INTO users (name, email) VALUES ('Chuck', 'csev@umich.edu');
DELETE FROM users WHERE email = 'ted@umich.edu';
UPDATE users SET name = 'Charles' WHERE email='csev@umich.edu';
SELECT * FROM users WHERE name LIKE '%e%';
SELECT * FROM users ORDER BY email DESC LIMIT 2;
SELECT * FROM users ORDER BY email OFFSET 1 LIMIT 2;
SELECT COUNT(*) FROM users WHERE email = 'csev@umich.edu';
DROP TABLE users;
CREATE TABLE users (id SERIAL, name VARCHAR(128), email VARCHAR(128) UNIQUE, PRIMARY KEY (id);
SERIAL is used to generate a sequence of integers which are often used as the Primary key of a table.
CREATE TABLE animals(
   id SERIAL PRIMARY KEY,
   name VARCHAR NOT NULL
);

LOADING CSV FILE INTO TABLE
wget https://www.pg4e.com/tools/sql/library.csv
CREATE TABLE track_raw (title TEXT, artist TEXT, album TEXT, count INTEGER, rating INTEGER, len INTEGER);
\copy track_raw(title,artist,album,count,rating,len) FROM 'library.csv' WITH DELIMITER ',' CSV;

CONCEPTS
PRIMARY KEY: generally an integer auto-increment field
LOGICAL KEY: what the outside world uses for lookup (ex. email of a person)
FOREIGN KEY: generally an integer key pointing to a row in another table (points to the primary key)
Never use your logical key as the primary key. Logical keys can and do change, albeit slowly. Relationships that are based on matching string fields are less efficient than 
integers.
SERIAL: keyword added to primary keys in a CREATE TABLE statement to indicate that the database is to provide a value for the column when records are inserted

BUILDING TABLES
CREATE TABLE artist (id SERIAL, name VARCHAR(128) UNIQUE, PRIMARY KEY(id));
CREATE TABLE album (id SERIAL, title VARCHAR(128), artist_id INTEGER REFERENCES artist(id) ON DELETE CASCADE, PRIMARY KEY(id));
artist_id is a foreign key; ON DELETE CASCADE: if we delete the artist, all the rows with artist_id related to that artist go away
CREATE TABLE genre (id SERIAL, name VARCHAR(128) UNIQUE, PRIMARY KEY(id));
CREATE TABLE track(id SERIAL, title VARCHAR(128), len INTEGER, rating INTEGER, count INTEGER, album_id INTEGER REFERENCES album(id) ON DELETE CASCADE, genre_id INTEGER
REFERENCES genre(id) ON DELETE CASCADE, UNIQUE(title, album_id), PRIMARY KEY(id));
The combination of title and album_id must be unique, not each one individually must be unique
\d track: shows track schema
INSERT INTO artist (name) VALUES ('Led Zeppelin');
INSERT INTO artist (name) VALUES ('AC/DC');
INSERT INTO album (title), artist_id) VALUES ('Who Made Who', 2);
INSERT INTO album (title, artist_id) VALUES ('IV', 1);
INSERT INTO genre (name) VALUES ('Rock');
INSERT INTO genre (name) VALUES ('Metal');
INSERT INTO track (title, rating, len, count, album_id, genre_id) VALUES ('Black Dog', 5, 297, 0, 2, 1);
INSERT INTO track (title, rating, len, count, album_id, genre_id) VALUES ('Stairway', 5, 482, 0, 2 1);
INSERT INTO track (title, rating, len, count, album_id, genre_id) VALUES ('About to Rock', 5, 313, 0, 1, 2);
INSERT INTO track (title, rating, len, count, album_id, genre_id) VALUES ('Who Made Who', 5, 207, 0, 1, 2);

JOIN
keyword that reconnects rows with foreign keys with the corresponding data in the table that the foreign key points to.
SELECT album.title, artist.name FROM album JOIN artist ON album.artist_id = artist.id;
SELECT track.title, track.genre_id, genre.id, genre.name FROM track CROSS JOIN genre; (not very useful)
SELECT track.title, artist.name, album.title, genre.name FROM track
JOIN genre ON track.genre_id = genre.id
JOIN album ON track.album_id = album.id
JOIN artist ON album.artist_id = artist.id;

CASCADE
DELETE FROM Genre WHERE name = 'Metal';
We could instead use SET NULL (set the foreign key columns in the child rows to null) or DEFAULT/RESTRICT (don't allow changes that break the constraint)

MANY-TO-MANY RELATIONSHIPS
CREATE TABLE student (id SERIAL, name VARCHAR(128), email VARCHAR(128) UNIQUE, PRIMARY KEY(id));
CREATE TABLE course (id SERIAL, title VARCHAR(128) UNIQUE, PRIMARY KEY(id));
CREATE TABLE member (student_id INTEGER REFERENCES student(id) ON DELETE CASCADE, course_id INTEGER REFERENCES course(id) ON DELETE CASCADE, role INTEGER, 
PRIMARY KEY (student_id, course_id));
SELECT student.name, member.role, course.title FROM student
JOIN member ON member.student_id = student.id
JOIN course ON member.course_id = course.id;

---------------------------------------------- COURSE 2 ----------------------------------------------
ALTER TABLE COMMAND
ALTER TABLE fav DROP COLUMN oops;
ALTER TABLE post ALTER COLUMN content TYPE TEXT;
ALTER TABLE fav ADD COLUMN howmuch INTEGER;

READING COMMANDS FROM A FILE
=> \i 03-Techniques-load.sql

DATE TYPES
TIMESTAMPZ - timestamp with time zone.
NOW() is a built-in PostgreSQL function (has a timezone associated with it)
CREATE TABLE fav (id SERIAL, oops TEXT, created_at TIMESTAMPZ NOT NULL DEFAULT NOW());
DEFAULT NOW(): database will automatically insert default value for created_at value
SELECT NOW(), NOW() AT TIME ZONE 'UTC', NOW() AT TIME ZONE 'HST';
Store time stamps with time zones, prefer UTC for stored time stamps, convert to local time zone when retrieving.

CASTING
Convert from one type to another
postgres=# SELECT NOW() ::DATE, CAST(NOW() AS DATE), CAST(NOW() AS TIME);
:: indicates casting (CAST is another way to do it)

INTERVALS
We can do date interval arithmetic
postgres=# SELECT NOW(), NOW() - INTERVAL '2 days', (NOW() - INTERVAL '2 DAYS')::DATE;
Sometimes we want to discard some of the accuracy that is in a TIMESTAMP
SELECT id, content, created_at FROM comment WHERE created_at >= DATE_TRUNC('day', NOW()) AND created_at < DATE_TRUNC('day', NOW() + INTERVAL '1 day');

DISTINCT only returns unique rows in a result set - and row will only appear once
DISTINCT ON limits duplicate removal to a set of columns
SELECT DISTINCT model FROM racing;
SELECT DISTINCT ON (model) make, model FROM racing;

SELECT COUNT(abbrev), abbrev FROM pg_timezone_names GROUP BY abbrev;
SELECT COUNT(abbrev) AS ct, abbrev FROM pg_timezone_names WHERE is_dst = 't' GROUP BY abbrev HAVING COUNT(abbrev) > 10;

To implement atomicity, PostgreSQL locks areas before it starts an SQL command that might change an area of the database. All other access to that area must wait until the area
is unlock. So instead of
UPDATE tracks SET count = count + 1 WHERE id = 42
we could write
LOCK ROW 42 OF tracks 
READ count FROM tracks ROW 42
count = count + 1
WRITE count TO tracks ROW 42
UNLOCK ROW 42 OF tracks


ON CONFLICT DO
You may bump into a constraint
INSERT INTO fav (post_id, account_id, howmuch) VALUES (1,1,1) RETURNING *; will fail because that record had already been inserted, so you may use
INSERT INTO fav (post_id, account_id, howmuch) VALUES (1,1,1) ON CONFLICT (post_id, account_id) DO UPDATE SET howmuch = fav.howmuch + 1 RETURNING *;
































