## Course 1

POSTGRESQL DOWNLOAD
/etc/apt/sources.list.d/pgdg.list

BASIC COMMANDS
Acessar o postgresql (connecting to the server): psql -Upostgres -hlocalhost
Mostrar base de dados (starting a postgres server instance): \l
Sair do postgres=# (gets out of the session)(super user prompt, # indicates you are the superuser): \q
Sair do postgres@alex-Inspiron-5423:/home/alex$: exit (postgres is the super user)
psql is a client that we run locally
$ indica que temos um usuário normal; # é o administrador do sistema
Os comandos são, em geral, em letras minúsculas. Muitos deles aceitam argumentos. Os argumentos que começam com um (ou dois) “-” são opcionais.
O pipe (|) é usado para fazer encadeamento de processos, ou seja, faz com que a saída de um comando seja enviada como entrada para o próximo comando.
O > direciona a saída de um comando para um arquivo ou dispositivo.
O >>, assim como o >, também direciona a saída de um comando para um arquivo, a diferença é que ele não substitui o conteúdo do arquivo, mas acrescenta ao final.
Name: postgres, template0, template1 are native databases, we better not touch them
Show tabled: \dt

CREATING A USER AND DATABASE
postgres=# CREATE USER pg4e WITH PASSWORD 'secret';
postgres=# CREATE DATABASE people WITH OWNER 'pg4e';
Now in the database server, we have a new empty database and I have access credentials that I can get into that (the SQL client can now talk to the database)

CONNECTING TO THE DATABASE
~$ psql people pg4e -hlocalhost
people=> this is not a super user prompt
people=> \dt shows the tables inside the database people

CREATING A TABLE
people=> CREATE TABLE users(name VARCHAR(128), email VARCHAR(128));
people=> \d+ users shows the schema of the users table

WORKING WITH TABLES
INSERT INTO users (name, email) VALUES ('Chuck', 'csev@umich.edu');
DELETE FROM users WHERE email = 'ted@umich.edu';
UPDATE users SET name = 'Charles' WHERE email='csev@umich.edu';
SELECT * FROM users WHERE name LIKE '%e%';
SELECT * FROM users ORDER BY email DESC LIMIT 2;
SELECT * FROM users ORDER BY email OFFSET 1 LIMIT 2;
SELECT COUNT(*) FROM users WHERE email = 'csev@umich.edu';
DROP TABLE users;
CREATE TABLE users (id SERIAL, name VARCHAR(128), email VARCHAR(128) UNIQUE, PRIMARY KEY (id);
SERIAL is used to generate a sequence of integers which are often used as the Primary key of a table.
CREATE TABLE animals(
   id SERIAL PRIMARY KEY,
   name VARCHAR NOT NULL
);

LOADING CSV FILE INTO TABLE
wget https://www.pg4e.com/tools/sql/library.csv
CREATE TABLE track_raw (title TEXT, artist TEXT, album TEXT, count INTEGER, rating INTEGER, len INTEGER);
\copy track_raw(title,artist,album,count,rating,len) FROM 'library.csv' WITH DELIMITER ',' CSV;

CONCEPTS
PRIMARY KEY: generally an integer auto-increment field
LOGICAL KEY: what the outside world uses for lookup (ex. email of a person)
FOREIGN KEY: generally an integer key pointing to a row in another table (points to the primary key)
Never use your logical key as the primary key. Logical keys can and do change, albeit slowly. Relationships that are based on matching string fields are less efficient than 
integers.
SERIAL: keyword added to primary keys in a CREATE TABLE statement to indicate that the database is to provide a value for the column when records are inserted

BUILDING TABLES
CREATE TABLE artist (id SERIAL, name VARCHAR(128) UNIQUE, PRIMARY KEY(id));
CREATE TABLE album (id SERIAL, title VARCHAR(128), artist_id INTEGER REFERENCES artist(id) ON DELETE CASCADE, PRIMARY KEY(id));
artist_id is a foreign key; ON DELETE CASCADE: if we delete the artist, all the rows with artist_id related to that artist go away
CREATE TABLE genre (id SERIAL, name VARCHAR(128) UNIQUE, PRIMARY KEY(id));
CREATE TABLE track(id SERIAL, title VARCHAR(128), len INTEGER, rating INTEGER, count INTEGER, album_id INTEGER REFERENCES album(id) ON DELETE CASCADE, genre_id INTEGER
REFERENCES genre(id) ON DELETE CASCADE, UNIQUE(title, album_id), PRIMARY KEY(id));
The combination of title and album_id must be unique, not each one individually must be unique
\d track: shows track schema
INSERT INTO artist (name) VALUES ('Led Zeppelin');
INSERT INTO artist (name) VALUES ('AC/DC');
INSERT INTO album (title), artist_id) VALUES ('Who Made Who', 2);
INSERT INTO album (title, artist_id) VALUES ('IV', 1);
INSERT INTO genre (name) VALUES ('Rock');
INSERT INTO genre (name) VALUES ('Metal');
INSERT INTO track (title, rating, len, count, album_id, genre_id) VALUES ('Black Dog', 5, 297, 0, 2, 1);
INSERT INTO track (title, rating, len, count, album_id, genre_id) VALUES ('Stairway', 5, 482, 0, 2 1);
INSERT INTO track (title, rating, len, count, album_id, genre_id) VALUES ('About to Rock', 5, 313, 0, 1, 2);
INSERT INTO track (title, rating, len, count, album_id, genre_id) VALUES ('Who Made Who', 5, 207, 0, 1, 2);

JOIN
keyword that reconnects rows with foreign keys with the corresponding data in the table that the foreign key points to.
SELECT album.title, artist.name FROM album JOIN artist ON album.artist_id = artist.id;
SELECT track.title, track.genre_id, genre.id, genre.name FROM track CROSS JOIN genre; (not very useful)
SELECT track.title, artist.name, album.title, genre.name FROM track
JOIN genre ON track.genre_id = genre.id
JOIN album ON track.album_id = album.id
JOIN artist ON album.artist_id = artist.id;

CASCADE
DELETE FROM Genre WHERE name = 'Metal';
We could instead use SET NULL (set the foreign key columns in the child rows to null) or DEFAULT/RESTRICT (don't allow changes that break the constraint)

MANY-TO-MANY RELATIONSHIPS
CREATE TABLE student (id SERIAL, name VARCHAR(128), email VARCHAR(128) UNIQUE, PRIMARY KEY(id));
CREATE TABLE course (id SERIAL, title VARCHAR(128) UNIQUE, PRIMARY KEY(id));
CREATE TABLE member (student_id INTEGER REFERENCES student(id) ON DELETE CASCADE, course_id INTEGER REFERENCES course(id) ON DELETE CASCADE, role INTEGER, 
PRIMARY KEY (student_id, course_id));
SELECT student.name, member.role, course.title FROM student
JOIN member ON member.student_id = student.id
JOIN course ON member.course_id = course.id;

##  Course 2








