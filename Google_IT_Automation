************** USING PYTHON TO INTERACT WITH THE OPERATING SYSTEM **************

cat: command that shows the contents of a file
python3 hello_world.py: executes file
nano hello_world.py: edit file
shebang line: #!/usr/bin/env python3 (we add this line on top of the file (from nano) to tell the OS  what command we want to use to execute that script)
#!/usr/bin/env python3 uses the operating system env command, which locates and executes Python by searching the PATH environment variable. Unlike Windows, the Python 
interpreter is usually already in the $PATH variable on linux, so you don't have to add it.

To run our file directly, we want it to be executable; so we need: 
chmod +x hello_world.py 
Now we can run the file by just prefixing it with a dot slash
./hello_world.py
We need the ./ because the script isn't located in any of the directories listed in the path variable. This variable tells the OS where to find executables. The dot 
represents the current directory (find the script in the current directory and execute it)

vim, atom: linux text editors that have syntax highlighting

The shutil module offers a number of high-level operations on files and collections of files. In particular, it provides functions that support file copying and removal.
isk_usage() method is used to get disk usage statistics of the given path. This method returns a named tuple with the attributes total, used, and free. The total attribute 
represents the total amount of space, the used attribute represents the amount of used space, and the free attribute represents the amount of available space, in bytes.
psutil (Python system and process utilities) is a cross-platform library for retrieving information on the processes currently running and system utilization (CPU, memory, 
disks, network, sensors) in Python.
psutil.cpu_percent() returns a float showing the current system-wide CPU use as a percentage.

Requests is a Python module that you can use to send all kinds of HTTP requests. Features range from passing parameters in URLs to sending custom headers and SSL verification.
A request is when you ping a website for information.
You can add headers, form data, multi-part files, and parameters with simple Python dictionaries.You can then access the response data using the same request.

Use nano editor to create a new file network.py: nano network.py
check_localhost checks whether the local host is correctly configured. We do this by calling the gethostbyname within the function.

#!/usr/bin/env python3
import requests
import socket
def check_localhost():
        localhost = socket.gethostbyname('localhost')
        if localhost == '127.0.0.1':
                return True
        return False
def check_connectivity():
        request = requests.get("http://www.google.com") #This returns the website's status code.
        if request.status_code() == 200:
                return True
        retrurn False

(Estou em um nano de outro python file) To import network module at the beginning of the file: from network import *

file = open("spider.txt")
print(file.readline()) #reads a single line of the file
print(file.read()) #reads the entire file
file.close()

with open("spider.txt") as file: #file is automatically closed after the with
        print(file.readline())
        
with open("spider.txt") as file:
        for line in file:
                print(line.upper())

with open("spider.txt") as file:
        for line in file:
                print(line.strip().upper())
                
file = open("spider.txt")
lines = file.readlines()
file.close()
lines.sort()
print(lines)

with open("novel.txt", "w") as file:
        file.write("It was a dark and stormy night")
        
If you open a file for writing and the file already exists, the old contents will be deleted as soon as the file is opened.

import os 
os.remove("novel.txt") #deletes file
os.rename("first_draft.txt", "finished_masterpiece.txt")
os.path("finished_masterpiece.txt") #returns whether the file exists or not
os.path.getsize("spider.txt")
os.path.getmtime("spider.txt") #returns when file was last modified (seconds since 1970)
import datetime
timestamp = os.path.getmtime("spider.txt")
datetime.datetime.fromtimestamp(timestamp)
os.path.abspath("spider.txt") #returns the absolut path

print(os.getcwd())
os.mkdir("new_dir")
os.chdir("new_dir") #move para o diretorio new_dir
os.mkdir("newer_dir")
os.rmdir("newer_dir") #deleta newer_dir
os.listdir("dir2") #lists all files in that directory
-> ['images', 'index.html', 'favicon.ico']

dir = "dir2"
for name in os.listdir(dir):
        fullname =os.path.join(dir, name)
        if os.path.isdir(fullname):
                print("{} is a directory".format(fullname))
        else:
                print("{} is a file".format(fullname))

import os
# current working directory
path = os.getcwd()
print("Current Directory:", path)
# parent directory
parent = os.path.join(path, os.pardir)
# prints parent directory
print("\nParent Directory:", os.path.abspath(parent))
Output:
                Current Directory: /home/geeks/Desktop/gfg
                Parent Directory: /home/geeks/Desktop

Parsing: analyzing a file's content to correctly structure the data

import csv
f = open("csv_file.txt")
csv_f = csv.reader(f) #The reader() function of the CSV module will interpret the file as a CSV.
for row in csv_f:
        name, phone, role = row
        print("Name: {}, Phone: {}, Role: {}".format(name, phone, role))
f.close()

hosts = [["workstation.local", "192.168.25.46"], ["webserver.cloud", "10.2.5.6"]]
with open('hosts.csv', 'w') as hosts_csv:
        writer = csv.writer(hosts_csv)
        writer.writerows(hosts)
        
with open('software.csv') as software:
        reader = csv.DictReader(software)
        for row in reader:
                print("{} has {} users".format(row["name"], row["users"]))

user = [{"name": "Sol Mansi", "username": "solm", "department": "IT infrastructure"}, {"name": "Lio Nelson", "username": "lion", "department": "Development"}]
keys = ["name", "username", "department"]
with open('by_department.csv', 'w') as by_department:
        writer = csv.DictWriter(by_department, fieldnames = keys)
        writer.writeheader()
        writer.writerows(users)

REGULAR EXPRESSIONS

log = "July 31 bad_process[12345]: ERROR"
index = log.index("[")
print(log[index + 1 : index + 6])

import re 
log = "July 31 bad_process[12345]: ERROR"
regex = r"\[(\d+)\]"
result = re.search(regex, log)
print(result[1])
12345

The grep command utilizes regular expressions on Linux, but is not a part of the standard re Python module.
GREP prints out any line that matches the query that we pass in in the file that we give it. Let's check if we find "thon" inside the /usr/share/dict/words file (this file 
contains one word per line)
~$ grep thon /usr/share/dict/words
This command is case sensitive. If we want to match either lower or uppercase words, we have to add the -i parameter
~$ grep -i python /usr/share/dict/words

A dot matches any character (wildcard)
~$ grep l.rts /usr/share/dict/words

The circumflex [^] and the dollar sign [$] are anchor characters. They match the start and end of a line
^ and $ tell us where in the line the regex should match from (works with the lines, not the individual words)
^: beggining
$: end
Look for all the words that start with string fruit in the file
~$ grep ^fruit /usr/share/dict/words
Loof for all the words that end with cat
~$ grep cat$ /usr/share/dict/words

~$ nano regex.txt
GNU nano 4.8
abacate
minha alma foi embora
abelha motor
meu erro foi este
etanol
azeite
as muitas horas tomando leite
as muitas horas comendo abacate
~$ grep ^a regex.txt
abacate
abelha
azeite
as muitas horas tomando leite
as muitas horas comendo abacate
~$ grep e$ regex.txt
abacate
meu erro foi este
azeite
as muitas horas tomando leite
as muitas horas comendo abacate
~$ grep -e ^a -e e$ regex.txt
abacate
abelha
meu erro foi este
azeite
as muitas horas tomando leite
as muitas horas comendo abacate

r indicates that we're dealing with a rawstring (the python interpreter shouldn't try to interpret any special characters, instead should just pass the string to the function
as is
import re 
result = re.search(r"aza", "plaza")
print(result)
<re.Match object; span=(2, 5), match='aza'>

print(re.search(r"^x", "xenon"))
<re.Match object; span=(0,1), match='x'>

print(re.search(r"p.ng", "penguin")
<re.Match object; span=(0,4), match='peng'>

def check_aei (text):
  result = re.search(r"a.e.i", text)
  return result != None
print(check_aei("academia")) # True
print(check_aei("aerial")) # False
print(check_aei("paramedic")) # True

print(re.search(r"p.ng", "Pangaea", re.IGNORECASE))
<re.Match object; span=(0,4), match='Pang'>

print(re.search(r"[Pp]ython", "python")) # will match both Python and python
<re.Match object; span=(0, 6), match='python'>

[a-z] will match any lowercase letter
print(re.search(r"[a-z]way", "The end of the highway"))
<re.Match object; span=(18, 22), match='hway'>
print(re.search(r"[a-z]way", "What a way to go"))
None

print(re.search(r"cloud[a-zA-Z0-9]", "cloudy"))
<re.Match object; span=(0, 6), match='cloudy'>
print(re.search(r"cloud[a-zA-Z0-9]", "cloud9"))
<re.Match object; span=(0, 6), match='cloud9'>
print(re.search(r"cloud[a-9]", "cloud9"))
error: bad character range a-9

[^] searches for characters that aren't in the group
print(re.search(r"[^a-zA-Z]", "This is a sentence with spaces."))
<re.Match object; span=(4, 5), match=' '>
print(re.search(r"[^a-zA-Z ]", "This is a sentence with spaces."))
<re.Match object; span=(30, 31), match='.'>

| alternative options
print(re.search(r"cat|dog", "I like cats."))
<re.Match object; span=(7, 10), match='cat'>

findall returns all matches, not just the first one like search

print(re.findall(r"cat|dog", "I like both dogs and cats."))
['dog', 'cat']

.* matches any character repeated as many times as possible, including zero
print(re.search(r"Py.*n", "Pygmalion"))
<re.Match object; span=(0, 9), match='Pygmalion'>
print(re.search(r"Py.*n", "Python programming")) #exhibits greedy behavior
<re.Match object; span=(0, 17), match='Python programmin'>
print(re.search(r"Py[a-z]*n", "Python programming"))
<re.Match object; span=(0, 6), match='Python'>

+ matches one or more occurrences of the character that comes before it
print(re.search(r"o+l+", "goldfish"))
<re.Match object; span=(1, 3), match='ol'>
print(re.search(r"o+l+", "goooooolllllldfish"))
<re.Match object; span=(1, 13), match='oooooollllll'>
print(re.search(r"o+l+", "boil"))
None

? matches either zero or one occurrence of the character before it
print(re.search(r"p?each", "To each their own")) #the p is optional
<re.Match object; span=(3, 7), match='each'>
print(re.search(r"p?each", "I like peaches"))
<re.Match object; span=(7, 12), match='peach'>

\ allows for searching special characters
print(re.search(r"\.com", "welcome"))
None
print(re.search(r"\.com", "alex@usp.com"))
<re.Match object; span=(8, 12), match='.com'>

\w matches any alphanumeric character, including letters, numbers and underscores
print(re.search(r"\w*", "This is"))
<re.Match object; span=(0, 4), match='This'>
print(re.search(r"\w*", "And_this_is"))
<re.Match object; span=(0, 11), match='And_this_is'>

\d matches digits; \s matches whitespace characters (like space, tab and newline); \b matches word boundaries

Check if the text passed has at least 2 groups of alphanumeric characters (including letters, numbers, and underscores) separated by one or more whitespace characters.
import re
def check_character_groups(text):
  result = re.search(r"\w\s\w", text)
  return result != None
print(check_character_groups("One")) # False
print(check_character_groups("123  Ready Set GO")) # True
print(check_character_groups("username user_01")) # True
print(check_character_groups("shopping_list: milk, bread, eggs.")) # False

print(re.search(r"A.*a", "Argentina"))
<re.Match object; span=(0, 9), match='Argentina'>
print(re.search(r"A.*a", "Azerbaijan"))
<re.Match object; span=(0, 9), match='Azerbaija'>
print(re.search(r"^A.*a$", "Azerbaijan"))
None
print(re.search(r"^A.*a$", "Argentina"))
<re.Match object; span=(0, 9), match='Argentina'>

^[-a-zA-Z0-9_.]*$
^ = Match from the start of the input
[-a-zA-Z0-9_.] = A character class (a list of allowed characters):
- matches the literal '-' character (must be the first or last character in the class)
a-z matches lowercase alpha characters
A-Z matches uppercase alpha characters
0-9 matches the numeric characters
_ matches the literal '_' character
. matches the literal '.' character (unlike outside a character class, where it matches any character)
* = Match 0 to infinite characters (use + to match at least one character)
$ = Match to the end of the string

A variable name must start with a letter, can contain any number of letters, numbers or underscores
pattern = r"^[a-zA-Z_][a-zA-Z0-9_]*$"
print(re.search(pattern, "_this_is_valid"))
<re.Match object; span=(0, 14), match='_this_is_valid'>
print(re.search(pattern, "_this is not"))
None
print(re.search(pattern, "a"))
<re.Match object; span=(0, 1), match='a'>

Check if the text passed looks like a standard sentence, meaning that it starts with an uppercase letter, followed by at least some lowercase letters or a space, and ends 
with a period, question mark, or exclamation point.
import re
def check_sentence(text):
  result = re.search(r"^[A-Z][A-Za-z\s]+[\.!\?]$", text)
  return result != None
print(check_sentence("Is this is a sentence?")) # True
print(check_sentence("is this is a sentence?")) # False
print(check_sentence("Hello")) # False
print(check_sentence("1-2-3-GO!")) # False
print(check_sentence("A star is born.")) # True

import re
def check_web_address(text):
  pattern = r'^[A-Za-z._-]*$'
  result = re.search(pattern, text)
  return result != None
print(check_web_address("gmail.com")) # True
print(check_web_address("www@google")) # False
print(check_web_address("www.Coursera.org")) # True
print(check_web_address("web-address.com/homepage")) # False
print(check_web_address("My_Favorite-Blog.US")) # True

import re
def check_time(text):
  pattern = r"\b((1[0-2]|1?[1-9]):([0-5][0-9])( ?([AaPp][Mm])))"
  result = re.search(pattern, text)
  return result != None
print(check_time("12:45pm")) # True
print(check_time("9:59 AM")) # True
print(check_time("6:60am")) # False
print(check_time("five o'clock")) # False

import re
def check_zip_code (text):
  result = re.search(r" \d{5}| \d{5}-\d{4}", text)
  return result != None
print(check_zip_code("The zip codes for New York are 10001 thru 11104.")) # True
print(check_zip_code("90210 is a TV show")) # False
print(check_zip_code("Their address is: 123 Main Street, Anytown, AZ 85258-0001.")) # True
print(check_zip_code("The Parliament of Canada is at 111 Wellington St, Ottawa, ON K1A0A9.")) # False

Capturing groups: portions of the pattern that are enclosed in parentheses
last_name,first_name
result = re.search(r"^(\w*), (\w*)$", "Sandler, Adam")
<re.Match object; span=(0, 13), match='Sandler, Adam'>
print(result.groups())
('Sandler', 'Adam')
result[0]
Out[12]: 'Sandler, Adam'
result[1]
Out[13]: 'Sandler'
result[2]
Out[14]: 'Adam'
result[3]
IndexError: no such group

MANAGING DATA AND PROCESSES

Shell: command-line interface used to interact with the operating system.
Bash is the most commonly used shell on Linux.
Python programs get executed inside a shell command-line environment. The variables set in that environment (environment variables) are another source of information that we 
can use in our scripts. We can check the enviromnent variables using the env command
~$ env
Let's print out the contents of the PATH variable (echo is the command we use to print text in the linux shell; when we want to access the value of a variable in the shell,
we need to prefix the name of the variable with a $).
~$ echo $PATH
The shell uses the PATH variable to figure out where to look for executable files when we call them while specifying a directory; all those directories listed there are where
the shell will look for programs.

~$ cat variables.py
import os
print("HOME: " + os.environ.get("HOME", "")) # os.environ[HOME] would result in an error if there's no such key in that dictionary
print("SHELL: " + os.environ.get("SHELL", "")) # the get method allows us to specify a default value when the key isn't in the dictionary
print("FRUIT: " + os.environ.get("FRUIT", "")) # this means: retrieve value associated with that key; if no key is present then return ""
~$ ./variables.py
HOME: /home/user
SHELL: /bin/bash
FRUIT: 
Fruit is not defined in the current environment. To define it:
~$ export FRUIT=Pineapple
The export keyword tells the shell that we want the value that we set to be seen by any command that we call.
~$ ./variables.py
HOME: /home/user
SHELL: /bin/bash
FRUIT: Pineapple

Command-line arguments: parameters that are passed to a program when it's started
~$ cat parameters.py
#!/usr/bin/env python3
import sys
print(sys.argv)
~$ ./parameters.py
['./parameters.py']
~$ ./parameters.py one two three
['./parameters.py', 'one', 'two', 'three']

Exit status: the value returned by a program to the shell; = 0 when the process succeeds and != 0 when it fails (the actual number returned gives additional 
information on what kind of error the program encountered)
The ? variable lets us check the exit status of the last executed command
wc command: counts the number of lines, words and characters in a file
~$ wc variables.py
7 19 174 variables.py
~$ echo $?
0
that means wc ran successfully
~$ wc notpresent.py 
wc: notpresent.py: No such file or directory
~$ echo $?
1

import os
import sys
filename=sys.argv[1]
if not os.path.exists(filename):
        with open(filename, 'w') as f:
                f.write("New file created\n")
else:
        print("Error, the file {} already exists!".format(filename))
        sys.exit(1)
        
>>> import subprocess
>>> subprocess.run(["date"])
Tue 07 Jan 2020 02:34:44 PM PST
CompletedProcess(args=['date'], returncode = 0)
>>> subprocess.run(["sleep", "2"])
CompletedProcess(args=['sleep', '2'], returncode = 0)
>>> result = subprocess.run(["ls", "this_file_does_not_exist"])
ls: cannot access 'this_file_does_not_exist': No such file or directory
>>> print(result.returncode)
2
2 indicated there was an error

who command: indicates the users currently logged into a computer
host command: converts a host name to an IP address and vice versa

>>> result = subprocess.run(["host", "8.8.8.8"], capture_output = True)
>>> print(result.returncode)
0
>>> print(result.stdout)
b'8.8.8.8.in-addr.arpa domain name pointer dns.google.\n'
b indicates that this is not a proper string for python, it's actually an array of bytes. When we execute the command using run, Python doesn't know which 
encoding to use to process the output of the command, so it simply represents it as a series of bytes. If we want this to become a proper string, we use the 
decode method; by default, decode uses a UTF-8 encoding
>>> print(result.stdout.decode().split())
['8.8.8.8.in-addr.arpa', 'domain', 'name', 'pointer, 'dns.google.']

>>> result = subprocess.run(["rm", "does_not_exist"], capture_output = True)
>>> print(result.returncode)
1
>>> print(result.stdout)
b''
>>> print(result.stderr)
b"rm: cannot remove 'does_not_exist': No such file or directory\n"

The PATH variable indicates where the operating system will look for the executable programs 
~$ atom myapp.py
import os
import subprocess
my_env = os.environ.copy() #copying the os environ dictionary (contains the current environment variables)
my_env["PATH"] = os.pathsep.join(["/opt/myapp/", my_env["PATH"]]) #we are adding one extra directory to the PATH variable
result = subprocess.run(["myapp"], env=my_env)

PROCESSING LOG FILES

~$ cat syslog
Jul 6 14:01:23 computer.name CRON[29440]: USER (good_user)
Jul 6 14:02:08 computer.name jam_tag=psim[29187]: (UUID:006)
Jul 6 14:02:09 computer.name CRON[29440]: USER (naughty_user)
Jul 6 14:04:01 computer.name CRON[29440]: USER (naughty_user)

import sys
import re
logfile = sys.argv[1] #sys.argv is a list which contains the command-line arguments passed to the script; sys.argv[0] is the name of the script
usernames = {}
with open(logfile) as f:
        for line in f:
                if "CRON" not in line:
                        continue
                pattern = r"USER \((\w+)\)$"
                result = re.search(pattern, line)
                if result is None:
                        continue
                name = result[1]
                usernames[name] = usernames.get(name,0) + 1
print(usernames)
Since the username is found at the end of the log line, we use the dollar sign anchor to only match text that is at the end of the line. To find the username, 
we look for the word user followed by a string wrapped in parentheses (we need to escape those parentheses with a backslash). We use another couple of 
parentheses to create a capturing group; for the username itself, we're matching any alphanumeric characters \w+
No windows, se eu abrir o anaconda prompt, vou atÃ© o diretorio do script e arquivo e escrevo > python py.py "syslog.txt"

TESTING

Unit tests are used to verify that small, isolated parts of a program are correct.

import re
def rearrange_name(name):
        result = re.search(r"^([\w .]*), ([\w .]*)$", name)
        return "{} {}".format(result[2], result[1])
import unittest
class TestRearrange(unittest.TestCase):
        def test_basic(self):
                testcase = "Lovelace, Ada"
                expected = "Ada Lovelace"
                self.assertEqual(rearrange_name(testcase), expected)
unittest.main()
OUTPUT: Ran 1 test in 0.011s    OK

import re
def rearrange_name(name):
        result = re.search(r"^([\w .]*), ([\w .]*)$", name)
        return "{} {}".format(result[2], result[1])
import unittest
class TestRearrange(unittest.TestCase):
        def test_basic(self):
                testcase = "Lovelace, Ada"
                expected = "Ada Lovelace"
                self.assertEqual(rearrange_name(testcase), expected)
        def test_empty(self):
                testcase = ""
                expected = ""
                self.assertEqual(rearrange_name(testcase), expected)
unittest.main()
OUTPUT: Ran 2 tests in 0.002s   FAILED (errors=1)
This is an edge case problem. To deal with it:
def rearrange_name(name):
        result = re.search(r"^([\w .]*), ([\w .]*)$", name)
        if result is None:
                return ""
        return "{} {}".format(result[2], result[1])









































