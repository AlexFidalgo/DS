************** USING PYTHON TO INTERACT WITH THE OPERATING SYSTEM **************

cat: command that shows the contents of a file
python3 hello_world.py: executes file
nano hello_world.py: edit file
shebang line: #!/usr/bin/env python3 (we add this line on top of the file (from nano) to tell the OS  what command we want to use to execute that script)
#!/usr/bin/env python3 uses the operating system env command, which locates and executes Python by searching the PATH environment variable. Unlike Windows, the Python 
interpreter is usually already in the $PATH variable on linux, so you don't have to add it.

To run our file directly, we want it to be executable; so we need: 
chmod +x hello_world.py 
Now we can run the file by just prefixing it with a dot slash
./hello_world.py
We need the ./ because the script isn't located in any of the directories listed in the path variable. This variable tells the OS where to find executables. The dot 
represents the current directory (find the script in the current directory and execute it)

vim, atom: linux text editors that have syntax highlighting

The shutil module offers a number of high-level operations on files and collections of files. In particular, it provides functions that support file copying and removal.
isk_usage() method is used to get disk usage statistics of the given path. This method returns a named tuple with the attributes total, used, and free. The total attribute 
represents the total amount of space, the used attribute represents the amount of used space, and the free attribute represents the amount of available space, in bytes.
psutil (Python system and process utilities) is a cross-platform library for retrieving information on the processes currently running and system utilization (CPU, memory, 
disks, network, sensors) in Python.
psutil.cpu_percent() returns a float showing the current system-wide CPU use as a percentage.

Requests is a Python module that you can use to send all kinds of HTTP requests. Features range from passing parameters in URLs to sending custom headers and SSL verification.
A request is when you ping a website for information.
You can add headers, form data, multi-part files, and parameters with simple Python dictionaries.You can then access the response data using the same request.

Use nano editor to create a new file network.py: nano network.py
check_localhost checks whether the local host is correctly configured. We do this by calling the gethostbyname within the function.

#!/usr/bin/env python3
import requests
import socket
def check_localhost():
        localhost = socket.gethostbyname('localhost')
        if localhost == '127.0.0.1':
                return True
        return False
def check_connectivity():
        request = requests.get("http://www.google.com") #This returns the website's status code.
        if request.status_code() == 200:
                return True
        retrurn False

(Estou em um nano de outro python file) To import network module at the beginning of the file: from network import *

file = open("spider.txt")
print(file.readline()) #reads a single line of the file
print(file.read()) #reads the entire file
file.close()

with open("spider.txt") as file: #file is automatically closed after the with
        print(file.readline())
        
with open("spider.txt") as file:
        for line in file:
                print(line.upper())

with open("spider.txt") as file:
        for line in file:
                print(line.strip().upper())
                
file = open("spider.txt")
lines = file.readlines()
file.close()
lines.sort()
print(lines)

with open("novel.txt", "w") as file:
        file.write("It was a dark and stormy night")
        
If you open a file for writing and the file already exists, the old contents will be deleted as soon as the file is opened.

import os 
os.remove("novel.txt") #deletes file
os.rename("first_draft.txt", "finished_masterpiece.txt")
os.path("finished_masterpiece.txt") #returns whether the file exists or not
os.path.getsize("spider.txt")
os.path.getmtime("spider.txt") #returns when file was last modified (seconds since 1970)
import datetime
timestamp = os.path.getmtime("spider.txt")
datetime.datetime.fromtimestamp(timestamp)
os.path.abspath("spider.txt") #returns the absolut path

print(os.getcwd())
os.mkdir("new_dir")
os.chdir("new_dir") #move para o diretorio new_dir
os.mkdir("newer_dir")
os.rmdir("newer_dir") #deleta newer_dir
os.listdir("dir2") #lists all files in that directory
-> ['images', 'index.html', 'favicon.ico']

dir = "dir2"
for name in os.listdir(dir):
        fullname =os.path.join(dir, name)
        if os.path.isdir(fullname):
                print("{} is a directory".format(fullname))
        else:
                print("{} is a file".format(fullname))

import os
# current working directory
path = os.getcwd()
print("Current Directory:", path)
# parent directory
parent = os.path.join(path, os.pardir)
# prints parent directory
print("\nParent Directory:", os.path.abspath(parent))
Output:
                Current Directory: /home/geeks/Desktop/gfg
                Parent Directory: /home/geeks/Desktop

Parsing: analyzing a file's content to correctly structure the data

import csv
f = open("csv_file.txt")
csv_f = csv.reader(f) #The reader() function of the CSV module will interpret the file as a CSV.
for row in csv_f:
        name, phone, role = row
        print("Name: {}, Phone: {}, Role: {}".format(name, phone, role))
f.close()

hosts = [["workstation.local", "192.168.25.46"], ["webserver.cloud", "10.2.5.6"]]
with open('hosts.csv', 'w') as hosts_csv:
        writer = csv.writer(hosts_csv)
        writer.writerows(hosts)
        
with open('software.csv') as software:
        reader = csv.DictReader(software)
        for row in reader:
                print("{} has {} users".format(row["name"], row["users"]))

user = [{"name": "Sol Mansi", "username": "solm", "department": "IT infrastructure"}, {"name": "Lio Nelson", "username": "lion", "department": "Development"}]
keys = ["name", "username", "department"]
with open('by_department.csv', 'w') as by_department:
        writer = csv.DictWriter(by_department, fieldnames = keys)
        writer.writeheader()
        writer.writerows(users)

REGULAR EXPRESSIONS

log = "July 31 bad_process[12345]: ERROR"
index = log.index("[")
print(log[index + 1 : index + 6])

import re 
log = "July 31 bad_process[12345]: ERROR"
regex = r"\[(\d+)\]"
result = re.search(regex, log)
print(result[1])
12345

The grep command utilizes regular expressions on Linux, but is not a part of the standard re Python module.
GREP prints out any line that matches the query that we pass in in the file that we give it. Let's check if we find "thon" inside the /usr/share/dict/words file (this file 
contains one word per line)
~$ grep thon /usr/share/dict/words
This command is case sensitive. If we want to match either lower or uppercase words, we have to add the -i parameter
~$ grep -i python /usr/share/dict/words

A dot matches any character (wildcard)
~$ grep l.rts /usr/share/dict/words

The circumflex [^] and the dollar sign [$] are anchor characters. They match the start and end of a line
^ and $ tell us where in the line the regex should match from (works with the lines, not the individual words)
^: beggining
$: end
Look for all the words that start with string fruit in the file
~$ grep ^fruit /usr/share/dict/words
Loof for all the words that end with cat
~$ grep cat$ /usr/share/dict/words

~$ nano regex.txt
GNU nano 4.8
abacate
minha alma foi embora
abelha motor
meu erro foi este
etanol
azeite
as muitas horas tomando leite
as muitas horas comendo abacate
~$ grep ^a regex.txt
abacate
abelha
azeite
as muitas horas tomando leite
as muitas horas comendo abacate
~$ grep e$ regex.txt
abacate
meu erro foi este
azeite
as muitas horas tomando leite
as muitas horas comendo abacate
~$ grep -e ^a -e e$ regex.txt
abacate
abelha
meu erro foi este
azeite
as muitas horas tomando leite
as muitas horas comendo abacate

r indicates that we're dealing with a rawstring (the python interpreter shouldn't try to interpret any special characters, instead should just pass the string to the function
as is
import re 
result = re.search(r"aza", "plaza")
print(result)
<re.Match object; span=(2, 5), match='aza'>

print(re.search(r"^x", "xenon"))
<re.Match object; span=(0,1), match='x'>

print(re.search(r"p.ng", "penguin")
<re.Match object; span=(0,4), match='peng'>

def check_aei (text):
  result = re.search(r"a.e.i", text)
  return result != None
print(check_aei("academia")) # True
print(check_aei("aerial")) # False
print(check_aei("paramedic")) # True

print(re.search(r"p.ng", "Pangaea", re.IGNORECASE))
<re.Match object; span=(0,4), match='Pang'>

print(re.search(r"[Pp]ython", "python")) # will match both Python and python
<re.Match object; span=(0, 6), match='python'>

[a-z] will match any lowercase letter
print(re.search(r"[a-z]way", "The end of the highway"))
<re.Match object; span=(18, 22), match='hway'>
print(re.search(r"[a-z]way", "What a way to go"))
None

print(re.search(r"cloud[a-zA-Z0-9]", "cloudy"))
<re.Match object; span=(0, 6), match='cloudy'>
print(re.search(r"cloud[a-zA-Z0-9]", "cloud9"))
<re.Match object; span=(0, 6), match='cloud9'>
print(re.search(r"cloud[a-9]", "cloud9"))
error: bad character range a-9

[^] searches for characters that aren't in the group
print(re.search(r"[^a-zA-Z]", "This is a sentence with spaces."))
<re.Match object; span=(4, 5), match=' '>
print(re.search(r"[^a-zA-Z ]", "This is a sentence with spaces."))
<re.Match object; span=(30, 31), match='.'>

| alternative options
print(re.search(r"cat|dog", "I like cats."))
<re.Match object; span=(7, 10), match='cat'>

findall returns all matches, not just the first one like search

print(re.findall(r"cat|dog", "I like both dogs and cats."))
['dog', 'cat']

.* matches any character repeated as many times as possible, including zero
print(re.search(r"Py.*n", "Pygmalion"))
<re.Match object; span=(0, 9), match='Pygmalion'>
print(re.search(r"Py.*n", "Python programming")) #exhibits greedy behavior
<re.Match object; span=(0, 17), match='Python programmin'>
print(re.search(r"Py[a-z]*n", "Python programming"))
<re.Match object; span=(0, 6), match='Python'>

+ matches one or more occurrences of the character that comes before it
print(re.search(r"o+l+", "goldfish"))
<re.Match object; span=(1, 3), match='ol'>
print(re.search(r"o+l+", "goooooolllllldfish"))
<re.Match object; span=(1, 13), match='oooooollllll'>
print(re.search(r"o+l+", "boil"))
None

? matches either zero or one occurrence of the character before it
print(re.search(r"p?each", "To each their own")) #the p is optional
<re.Match object; span=(3, 7), match='each'>
print(re.search(r"p?each", "I like peaches"))
<re.Match object; span=(7, 12), match='peach'>

\ allows for searching special characters
print(re.search(r"\.com", "welcome"))
None
print(re.search(r"\.com", "alex@usp.com"))
<re.Match object; span=(8, 12), match='.com'>

\w matches any alphanumeric character, including letters, numbers and underscores
print(re.search(r"\w*", "This is"))
<re.Match object; span=(0, 4), match='This'>
print(re.search(r"\w*", "And_this_is"))
<re.Match object; span=(0, 11), match='And_this_is'>

\d matches digits; \s matches whitespace characters (like space, tab and newline); \b matches word boundaries

Check if the text passed has at least 2 groups of alphanumeric characters (including letters, numbers, and underscores) separated by one or more whitespace characters.
import re
def check_character_groups(text):
  result = re.search(r"\w\s\w", text)
  return result != None
print(check_character_groups("One")) # False
print(check_character_groups("123  Ready Set GO")) # True
print(check_character_groups("username user_01")) # True
print(check_character_groups("shopping_list: milk, bread, eggs.")) # False

print(re.search(r"A.*a", "Argentina"))
<re.Match object; span=(0, 9), match='Argentina'>
print(re.search(r"A.*a", "Azerbaijan"))
<re.Match object; span=(0, 9), match='Azerbaija'>
print(re.search(r"^A.*a$", "Azerbaijan"))
None
print(re.search(r"^A.*a$", "Argentina"))
<re.Match object; span=(0, 9), match='Argentina'>

^[-a-zA-Z0-9_.]*$
^ = Match from the start of the input
[-a-zA-Z0-9_.] = A character class (a list of allowed characters):
- matches the literal '-' character (must be the first or last character in the class)
a-z matches lowercase alpha characters
A-Z matches uppercase alpha characters
0-9 matches the numeric characters
_ matches the literal '_' character
. matches the literal '.' character (unlike outside a character class, where it matches any character)
* = Match 0 to infinite characters (use + to match at least one character)
$ = Match to the end of the string

A variable name must start with a letter, can contain any number of letters, numbers or underscores
pattern = r"^[a-zA-Z_][a-zA-Z0-9_]*$"
print(re.search(pattern, "_this_is_valid"))
<re.Match object; span=(0, 14), match='_this_is_valid'>
print(re.search(pattern, "_this is not"))
None
print(re.search(pattern, "a"))
<re.Match object; span=(0, 1), match='a'>

Check if the text passed looks like a standard sentence, meaning that it starts with an uppercase letter, followed by at least some lowercase letters or a space, and ends 
with a period, question mark, or exclamation point.
import re
def check_sentence(text):
  result = re.search(r"^[A-Z][A-Za-z\s]+[\.!\?]$", text)
  return result != None
print(check_sentence("Is this is a sentence?")) # True
print(check_sentence("is this is a sentence?")) # False
print(check_sentence("Hello")) # False
print(check_sentence("1-2-3-GO!")) # False
print(check_sentence("A star is born.")) # True

import re
def check_web_address(text):
  pattern = r'^[A-Za-z._-]*$'
  result = re.search(pattern, text)
  return result != None
print(check_web_address("gmail.com")) # True
print(check_web_address("www@google")) # False
print(check_web_address("www.Coursera.org")) # True
print(check_web_address("web-address.com/homepage")) # False
print(check_web_address("My_Favorite-Blog.US")) # True

import re
def check_time(text):
  pattern = r"\b((1[0-2]|1?[1-9]):([0-5][0-9])( ?([AaPp][Mm])))"
  result = re.search(pattern, text)
  return result != None
print(check_time("12:45pm")) # True
print(check_time("9:59 AM")) # True
print(check_time("6:60am")) # False
print(check_time("five o'clock")) # False

import re
def check_zip_code (text):
  result = re.search(r" \d{5}| \d{5}-\d{4}", text)
  return result != None
print(check_zip_code("The zip codes for New York are 10001 thru 11104.")) # True
print(check_zip_code("90210 is a TV show")) # False
print(check_zip_code("Their address is: 123 Main Street, Anytown, AZ 85258-0001.")) # True
print(check_zip_code("The Parliament of Canada is at 111 Wellington St, Ottawa, ON K1A0A9.")) # False

Capturing groups: portions of the pattern that are enclosed in parentheses
last_name,first_name
result = re.search(r"^(\w*), (\w*)$", "Sandler, Adam")
<re.Match object; span=(0, 13), match='Sandler, Adam'>
print(result.groups())
('Sandler', 'Adam')
result[0]
Out[12]: 'Sandler, Adam'
result[1]
Out[13]: 'Sandler'
result[2]
Out[14]: 'Adam'
result[3]
IndexError: no such group

MANAGING DATA AND PROCESSES

Shell: command-line interface used to interact with the operating system.
Bash is the most commonly used shell on Linux.
Python programs get executed inside a shell command-line environment. The variables set in that environment (environment variables) are another source of information that we 
can use in our scripts. We can check the enviromnent variables using the env command
~$ env
Let's print out the contents of the PATH variable (echo is the command we use to print text in the linux shell; when we want to access the value of a variable in the shell,
we need to prefix the name of the variable with a $).
~$ echo $PATH
The shell uses the PATH variable to figure out where to look for executable files when we call them while specifying a directory; all those directories listed there are where
the shell will look for programs.

~$ cat variables.py
import os
print("HOME: " + os.environ.get("HOME", "")) # os.environ[HOME] would result in an error if there's no such key in that dictionary
print("SHELL: " + os.environ.get("SHELL", "")) # the get method allows us to specify a default value when the key isn't in the dictionary
print("FRUIT: " + os.environ.get("FRUIT", "")) # this means: retrieve value associated with that key; if no key is present then return ""
~$ ./variables.py
HOME: /home/user
SHELL: /bin/bash
FRUIT: 
Fruit is not defined in the current environment. To define it:
~$ export FRUIT=Pineapple
The export keyword tells the shell that we want the value that we set to be seen by any command that we call.
~$ ./variables.py
HOME: /home/user
SHELL: /bin/bash
FRUIT: Pineapple

Command-line arguments: parameters that are passed to a program when it's started
~$ cat parameters.py
#!/usr/bin/env python3
import sys
print(sys.argv)
~$ ./parameters.py
['./parameters.py']
~$ ./parameters.py one two three
['./parameters.py', 'one', 'two', 'three']

Exit status: the value returned by a program to the shell; = 0 when the process succeeds and != 0 when it fails (the actual number returned gives additional 
information on what kind of error the program encountered)
The ? variable lets us check the exit status of the last executed command
wc command: counts the number of lines, words and characters in a file
~$ wc variables.py
7 19 174 variables.py
~$ echo $?
0
that means wc ran successfully
~$ wc notpresent.py 
wc: notpresent.py: No such file or directory
~$ echo $?
1

import os
import sys
filename=sys.argv[1]
if not os.path.exists(filename):
        with open(filename, 'w') as f:
                f.write("New file created\n")
else:
        print("Error, the file {} already exists!".format(filename))
        sys.exit(1)
        
>>> import subprocess
>>> subprocess.run(["date"])
Tue 07 Jan 2020 02:34:44 PM PST
CompletedProcess(args=['date'], returncode = 0)
>>> subprocess.run(["sleep", "2"])
CompletedProcess(args=['sleep', '2'], returncode = 0)
>>> result = subprocess.run(["ls", "this_file_does_not_exist"])
ls: cannot access 'this_file_does_not_exist': No such file or directory
>>> print(result.returncode)
2
2 indicated there was an error

who command: indicates the users currently logged into a computer
host command: converts a host name to an IP address and vice versa

>>> result = subprocess.run(["host", "8.8.8.8"], capture_output = True)
>>> print(result.returncode)
0
>>> print(result.stdout)
b'8.8.8.8.in-addr.arpa domain name pointer dns.google.\n'
b indicates that this is not a proper string for python, it's actually an array of bytes. When we execute the command using run, Python doesn't know which 
encoding to use to process the output of the command, so it simply represents it as a series of bytes. If we want this to become a proper string, we use the 
decode method; by default, decode uses a UTF-8 encoding
>>> print(result.stdout.decode().split())
['8.8.8.8.in-addr.arpa', 'domain', 'name', 'pointer, 'dns.google.']

>>> result = subprocess.run(["rm", "does_not_exist"], capture_output = True)
>>> print(result.returncode)
1
>>> print(result.stdout)
b''
>>> print(result.stderr)
b"rm: cannot remove 'does_not_exist': No such file or directory\n"

The PATH variable indicates where the operating system will look for the executable programs 
~$ atom myapp.py
import os
import subprocess
my_env = os.environ.copy() #copying the os environ dictionary (contains the current environment variables)
my_env["PATH"] = os.pathsep.join(["/opt/myapp/", my_env["PATH"]]) #we are adding one extra directory to the PATH variable
result = subprocess.run(["myapp"], env=my_env)

PROCESSING LOG FILES

~$ cat syslog
Jul 6 14:01:23 computer.name CRON[29440]: USER (good_user)
Jul 6 14:02:08 computer.name jam_tag=psim[29187]: (UUID:006)
Jul 6 14:02:09 computer.name CRON[29440]: USER (naughty_user)
Jul 6 14:04:01 computer.name CRON[29440]: USER (naughty_user)

import sys
import re
logfile = sys.argv[1] #sys.argv is a list which contains the command-line arguments passed to the script; sys.argv[0] is the name of the script
usernames = {}
with open(logfile) as f:
        for line in f:
                if "CRON" not in line:
                        continue
                pattern = r"USER \((\w+)\)$"
                result = re.search(pattern, line)
                if result is None:
                        continue
                name = result[1]
                usernames[name] = usernames.get(name,0) + 1
print(usernames)
Since the username is found at the end of the log line, we use the dollar sign anchor to only match text that is at the end of the line. To find the username, 
we look for the word user followed by a string wrapped in parentheses (we need to escape those parentheses with a backslash). We use another couple of 
parentheses to create a capturing group; for the username itself, we're matching any alphanumeric characters \w+
No windows, se eu abrir o anaconda prompt, vou até o diretorio do script e arquivo e escrevo > python py.py "syslog.txt"

TESTING

Unit tests are used to verify that small, isolated parts of a program are correct.

import re
def rearrange_name(name):
        result = re.search(r"^([\w .]*), ([\w .]*)$", name)
        return "{} {}".format(result[2], result[1])
import unittest
class TestRearrange(unittest.TestCase):
        def test_basic(self):
                testcase = "Lovelace, Ada"
                expected = "Ada Lovelace"
                self.assertEqual(rearrange_name(testcase), expected)
unittest.main()
OUTPUT: Ran 1 test in 0.011s    OK

import re
def rearrange_name(name):
        result = re.search(r"^([\w .]*), ([\w .]*)$", name)
        return "{} {}".format(result[2], result[1])
import unittest
class TestRearrange(unittest.TestCase):
        def test_basic(self):
                testcase = "Lovelace, Ada"
                expected = "Ada Lovelace"
                self.assertEqual(rearrange_name(testcase), expected)
        def test_empty(self):
                testcase = ""
                expected = ""
                self.assertEqual(rearrange_name(testcase), expected)
unittest.main()
OUTPUT: Ran 2 tests in 0.002s   FAILED (errors=1)
This is an edge case problem. To deal with it:
def rearrange_name(name):
        result = re.search(r"^([\w .]*), ([\w .]*)$", name)
        if result is None:
                return ""
        return "{} {}".format(result[2], result[1])
        def test_one_name(self):
                testcase = "Voltaire"
                expected = "Voltaire"
                self.assertEqual(rearrange_name(testcase), expected)
  AssertionError
def rearrange_name(name):
        result = re.search(r"^([\w .]*), ([\w .]*)$", name)
        if result is None:
                return name
        return "{} {}".format(result[2], result[1])

White-box testing: relies on the test creator's knowledge of the software being tested to construct the test cases
Black-box testing: the tester doesn't know the internals of how the software works; it's written with an awareness of what the program is supposed to do, but not how
it does it

Test-Driven Development: relies on software requirements being converted to test cases before software is fully developed, and tracking all software development by 
repeatedly testing the software against all test cases.

def character_frequency(filename):
        """Counts the frequency of each character in a given file."""
        try:
                f = open(filename)
        except OSError:
                return None
        characters = {}
        for line in f:
                for char in line:
                        characters[char] = characters.get(char, 0) + 1
        f.close()
        return characters
        
def validate_user (username, minlen):
        assert type(username) == str, "username must be a string"
        if minlen < 1:
                raise ValueError("minlen must be at least 1")
        if len(username) < minlen:
                return False
        if not username.isalnum():
                return False
        return True
        
import unittest
from validations import validate_user
class TestValidateUser (unittest.TestCase):
        def test_valid(self):
                self.assertEqual(validate_user("validuser", 3), True)
        def test_too_short(self):
                self.assertEqual(validate_user("inv", 5), False)
        def test_invalid_characters(self):
                self.assertEqual("invalid_user", 1), False)
        def test_invalid_minlen(self):
                self.assertRaises(ValueError, validate_user, "user", -1)
unittest.main()
        
BASH SCRIPTING

echo: prints messages to the screen
cat: shows contents of files
ls: lists contents of a directory
chmod: changes permissions of a file
mkdir: creates directory
cd: changes directory
cp: copies file
mv: moves or renames a file

..: reverses to the previous directory in the absolute path
.: reverses to the current directory

$ cp ../spyder.txt . (copies the spyder.txt file located in the previous directory to this directory)
$ touch myfile.txt (creates an empty file)
$ mv myfile.txt emptyfile.txt (renames file)
$ cp spyder.txt yetanotherfile.txt (creates a copy of spyder.txt)
$ rm * (removes all files)
$ rmdir mynewdir/ (deletes directory)

> overwrites
>> appends
$ cat stdout_example.py
#!/usr/bin/env python3
print("Just a bit of text")
$ ./stdout_example.py > new_file.txt
$ cat new_file.txt
Just a bit of text
$ ./stdout_example.py >> new_file.txt
$ cat new_file.txt
Just a bit of text
Just a bit of text

2> redirects errors
$ cat streams_err.py
#!/usr/bin/env python3
data = input("This will come from STDIN: ")
print("Now we write it to STDOUT: " + data)
raise ValueError("Now we generate an error to STDERR")
$ ./streams_err.py < new_file.txt
This will come from STDIN: Now we write it to STDOUT: Just a bit of text
ValueError: Now we generate an error to STDERR
$ ./streams_err.py < new_file.txt 2> error_file.txt
        
$ echo "These are the contents of the file" > myfile.txt
$ cat myfile.txt
These are the contents of the file
        
PIPES connect the output of one program to the input of another in order to pass data between programs
|: pipe command
$ ls -l | less
Here the output of the ls -l command is connected to the input of the less, which is a terminal paging program

tr command: translate; takes the characters in the first parameter and then transforms them into a character in the second parameter
uniq command: displays each match once
-c flag: prefixes each unique line with a number of times it occurred
-nr: sorts results numerically and in reverse order, from most to least hits
head command: prints the first 10 lines to stdl
$ cat spider.txt | tr ' ' '\n' | sort | uniq -c | sort -nr | head

Python can read from standard input using the stdin file object provided by the sys module
$ cat capitalize.py
#!/usr/bin/env python3
import sys
for line in sys.stdin:
        print(line.strip().capitalize())
$ cat haiku.txt
advance the fight,
automate it all.
$ cat haiku.txt | ./capitalize.py
Advance the fight,
Automate it all.
$ ./capitalize.py < haiku.txt
Advance the fight,
Automate it all.

Signals: tokens delivered to running processes to indicate a desired action
$ ping www.example.com
ctrl c interrupts it (not abruptly); the process received a signal indicating that we wanted it to stop
ctrl z causes the program to stop running without actually terminating; fg makes it run again
kill tells the program to terminate. Since kill is a separate program, we need to run it on a separate terminal; we also need to know the Process Identifier
(PID) of the process we want to send the signal to.
ps: lists the currently running programs
ps ax: lists all the running processes in the current computer; we may combine it with the grep command to only keep lines that contain the name of 
the process that we're looking for
$ ps ax | grep ping 
$ kill 4619

Managing files and directories
cd directory: changes the current working directory to the specified one
pwd: prints the current working directory
ls: lists the contents of the current directory
ls directory: lists the contents of the received directory  
ls -l: lists the additional information for the contents of the directory  
ls -a: lists all files, including those hidden  
ls -la: applies both the -l and the -a flags  
mkdir directory: creates the directory with the received name
rmdir directory: deletes the directory with the received name (if empty)
cp old_name new_name: copies old_name into new_name
mv old_name new_name: moves old_name into new_name
touch file_name: creates an empty file or updates the modified time if it exists
chmod modifiers files: changes the permissions for the files according to the provided modifiers; we've seen +x to make the file executable
chown user files: changes the owner of the files to the given user
chgrp group files: changes the group of the files to the given group

Operating with the content of files
cat file: shows the content of the file through standard output
wc file: counts the amount of characters, words, and lines in the given file; can also count the same values of whatever it receives via stdin
file file: prints the type of the given file, as recognized by the operating system
head file: shows the first 10 lines of the given file
tail file: shows the last 10 lines of the given file
less file: scrolls through the contents of the given file (press "q" to quit)
sort file: sorts the lines of the file alphabetically
cut -dseparator -ffields file: for each line in the given file, splits the line according to the given separator and prints the given fields (starting from 1)

Additional commands
echo "message": prints the message to standard output
date: prints the current date
who: prints the list of users currently logged into the computer
man command: shows the manual page of the given command; manual pages contain a lot of information explaining how to use each command (press "q" to quit)
uptime: shows how long the computer has been running
free: shows the amount of unused memory on the current system 

Managing streams
These are the redirectors that we can use to take control of the streams of our programs
command > file: redirects standard output, overwrites file
command >> file: redirects standard output, appends to file
command < file: redirects standard input from file
command 2> file: redirects standard error to file
command1 | command2: connects the output of command1 to the input of command2

Operating with processes
These are some commands that are useful to know in Linux when interacting with processes. Not all of them are explained in videos, so feel free to investigate 
them on your own.
ps: lists the processes executing in the current terminal for the current user
ps ax: lists all processes currently executing for all users  
ps e: shows the environment for the processes listed  
kill PID: sends the SIGTERM signal to the process identified by PID
fg: causes a job that was stopped or in the background to return to the foreground
bg: causes a job that was stopped to go to the background
jobs: lists the jobs currently running or stopped
top: shows the processes currently using the most CPU time (press "q" to quit)

#!/bin/bash
echo "Starting at: $(date)"
echo
echo "UPTIME"
uptime
echo
echo "FREE"
free
echo
echo "WHO"
who
echo
echo "Finishing at: $(date)"

$ ./gather-information.sh

$ example=hello
$ echo example
hello

#!/bin/bash
line="-----------------------------"
echo "Starting at: $(date)"; echo line
echo "UPTIME"; uptime; echo line
echo "FREE"; free; echo line
echo "WHO"; who; echo line
echo "Finishing at: $(date)"

Globs are characters that allow us to create lists of files. * and ? are the most common globs. Using these globs lets us create sequences of filenames that
we can use as parameters to the commands we call in our scripts
$ echo *.py (returns a list with all the filenames that end with py in the current directory)
$ echo c* (returns all the files in the current directory that start with the letter c)
Python files with 5 characters in their name:
$ echo $$$$$.py

$? checks the exit status of commands
In bash scripting, an exit value of 0 means success.
We want to check if the /etc/hosts file contains an entry for 127.0.0.1
grep will return an exit status of 0 when it finds at least one match
$ cat check_localhost.sh
#!/bin/bash
if grep "127.0.0.1" /etc/hosts; then
        echo "Everything ok"
else
        echo "ERROR! 127.0.0.1 is not in /etc/host"
fi
$ ./check_localhost.sh
127.0.0.1       localhost
Everything ok
The first line in the output is the one generated by the grep command, by default it prints the lines that match the expression that we give it
test: command that evaluates the conditions received and exits with zero when they're true and with one when they're false
-n checks if a string variable is empty or not
$ if test -n "$PATH"; then echo "Your path is not empty"; fi
same as:
$ if [ -n "$PATH"]; then echo "Your path is not empty"; fi

$ cat while.sh
#!/bin/bash
n=1
while [ $n -le 5 ]; do
        echo "Iteration number $n"
        ((n+=1))
done
checks if variable n is less than or equal to 5
$ ./while.sh
Iteration number 1
Iteration number 2
Iteration number 3
Iteration number 4
Iteration number 5

$ cat random-exit.py
#!/usr/bin/env python
import sys
import random
value=random.randint(0,3)
print("Returning: " + str(value))
sys.exit(value)

#!/bin/bash
n=0
command=$1
while ! $command && [ $n -le 5 ]; do
        sleep $n
        ((n=n+1))
        echo "Retry #$n"
done;

$1 (dollar-sign followed by one) returns the first command line argument (same as sys.argv[1])
If the received command fails, we will retry up to 5 times

$ ./retry.sh ./random-exit.py       (random-exit is the command line argumento to retry)
Returning: 1
Retry #1
Returning: 3
Retry #2
Returning: 1
Retry #3
Returning: 0

$ cat fruits.sh
for fruit in peach orange apple; do
        echo "I like $fruit!"
done

$ cd old_website/
ls -l
about.HTM
contact.HTM
footer.HTM
header.HTM
index.HTM

basename: command that takes a filename and an extension and then returns the name without the extension
$ basename index.HTM .HTM
index

#!/bin/bash
for file in *.HTM; do
        name=$(basename "$file" .HTM)        "" is good practice cause file could contain spaces
        echo mv "$file" "$name.html"         first we run echo to see if it's doing what it's supposed to do. Afterwards we run mv
done

$ chmod +x rename.sh
$ ./rename.sh
mv about.HTM about.html
mv contact.HTM contact.html
mv footer.HTM footer.html
mv header.HTM header.html
mv index.HTM index.html

#!/bin/bash
for file in *.HTM; do
        name=$(basename "$file" .HTM)        "" is good practice cause file could contain spaces
        mv "$file" "$name.html"         first we run echo to see if it's doing what it's supposed to do. Afterwards we run mv
done

$ ./rename.sh
$

changeJane.py:
#!/usr/bin/env python3
import sys
import subprocess
f = open(sys.argv[1], "r")
for line in f.readlines():
        old_name = line.strip()
        new_name = old_name.replace("jane", "jdoe")
        subprocess.run(["mv", old_name, new_name])
f.close()
$ ./changeJane.py oldFiles.txt

WEEK 7 FINAL ASSESSMENT ------------------------------------------------------------------------------------------------
import re
import csv
import operator

os_logs = open("syslog.log","r").readlines()
contagem_dos_logs = dict()

for log in os_logs:
    error = re.findall(r'ERROR.*\(',log)

    if len(error) != 0:
        texto_dos_logs = error[0].replace("ERROR","").replace("(","").strip()
        if texto_dos_logs in contagem_dos_logs.keys():
            contagem_dos_logs[texto_dos_logs] += 1
        else:
            contagem_dos_logs[texto_dos_logs] = 1
            
contagem_dos_logs = sorted(contagem_dos_logs.items(), key = operator.itemgetter(1), reverse=True)

with open('error_message.csv', 'w', newline='') as csvfile:
    writer_do_spam = csv.writer(csvfile, delimiter=',',
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
    writer_do_spam.writerow(["Error","Count"])

for log in contagem_dos_logs:
    key,value = log
    with open('error_message.csv', 'a', newline='') as csvfile:
        writer_do_spam = csv.writer(csvfile, delimiter=',',quotechar='|', quoting=csv.QUOTE_MINIMAL)
        writer_do_spam.writerow([key,value])
        
informacao_dos_count = dict()
contagem_dos_erros = dict()
for log in os_logs:
    username = re.search(r'\(.*\)',log).group().strip("()")
    error = re.search(r'(ERROR|INFO)',log).group()
    if error == "ERROR":
        if username in contagem_dos_erros.keys():
            contagem_dos_erros[username] += 1
        else:
            contagem_dos_erros[username] = 1
    else:
        if username in informacao_dos_count.keys():
            informacao_dos_count[username] += 1
        else:
            informacao_dos_count[username] = 1

with open('user_statistics.csv', 'w', newline='') as csvfile:
    writer_do_spam = csv.writer(csvfile, delimiter=',',
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
    writer_do_spam.writerow(["Username", "INFO", "ERROR"])

i = set(informacao_dos_count.keys())
e= set(contagem_dos_erros.keys())
z = e-i
d = dict.fromkeys(z,0)
informacao_dos_count.update(d)

informacao_dos_count = sorted(informacao_dos_count.items(),key=operator.itemgetter(0))
contagem_dos_erros = sorted(contagem_dos_erros.items(),key=operator.itemgetter(0))

username = [i[0] for i in informacao_dos_count]
valor1 = [i[1] for i in informacao_dos_count]
valor2 = [i[1] for i in contagem_dos_erros]
error_info = zip(valor1,valor2)
final = list(zip(username,error_info))[:8]

for i,j in final:
    with open('user_statistics.csv', 'a', newline='') as csvfile:
        writer_do_spam = csv.writer(csvfile, delimiter=',',quotechar='|', quoting=csv.QUOTE_MINIMAL)
        writer_do_spam.writerow([i,j[0],j[1]]) 
-----------------------------------------------------------------------------------------------------------------------------------------

******************************************************* GIT AND GITHUB **************************************************
cd
cd 'OneDrive - QMC Telecom'/'Área de Trabalho'/Coursera/google/Git_Github
cd checks


diff: takes two files or two directories and shows the differences between them
$ diff rearrange1.py rearrange2.py
$ diff -u val1.py val2.py (-u shows differences in a different format)
wdiff: shows the words that were changed in a file

diff -u old_file new_file > change.diff
>: redirects the output of the diff command to a file
patch takes a file generated by diff and applies the changes to the original file 
$ patch cpu_usage.py < cpu_usage.diff

$ mkdir checks
$ cd checks
$ git init
Whenever you clone a repository, the git repository is copied to you computer
The git directory acts as a database for all the changes tracked in Git and the working tree acts as a sandbox where we can edit the current versions of the files.
The git directory contains the history of all the files and changes. The working tree contains the current state of the project, including any changes that we've
made. The staging area contains the changes that have been marked to be included in the next commit
$ nano Hello.py
$ git add Hello.py 
Now Git tracks the Hello.py file. With that, we've added our file to the staging area.
Staging area: a file maintained by Gity that contains all of the information about what files and changes are going to go into your next commit.
git status command: get information about the current working tree and pending changes
$ git status
No commits yet
Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   Hello.py

Change default editor: git config --global core.editor "nano"

$git commit (opens nano) and lets us write a commit message
I commited.
$ git status
On branch master
nothing to commit, working tree clean

States of a file:
- MODIFIED: Changes have been made to this file but they haven't been commited yet (Git won't store any changes until we add them to the staging area
- STAGED: The changes to the file are ready to be commited to the project
- COMMITED: The changes made to it are stored in a snapshot in the Git directory
After modifying a file, we need to stage those changes and then commit them afterwards.

$ nano Hello.py
-/ modifying the file /-
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   Hello.py
$ git add Hello.py (this command adds the current changes in the file to the list of changes to be commited; after it, the file is part of the staging area)
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   Hello.py
$ git commit -m 'Inserts new print.'
[master 7883e37] Inserts new print.
 1 file changed, 1 insertion(+)
$ git status
On branch master
nothing to commit, working tree clean

$ mkdir scripts
$ cd scripts
$ git init
Initialized empty Git repository in C:/Users/AlexFidalgoZamikhows/OneDrive - QMC Telecom/Área de Trabalho/Coursera/google/Git_GitHub/scripts/.git/
$ chmod +x all_checks.py
$ git status
On branch master
No commits yet
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        all_checks.py
nothing added to commit but untracked files present (use "git add" to track)
$ git add all_checks.py (modified -> staged)
$ git commit (staged -> commited)

You can’t commit with an empty commit message.

$ nano all_checks.py
$ git add all_checks.py
$ git commit
$ git commit -m 'Add a check_reboot function'

$ git log
commit c665c407a0b62cc0de0cde953c6e12639546f648 (HEAD -> master)
Author: AlexFidalgo <alexfidalgo10@gmail.com>
Date:   Fri Jul 1 10:49:04 2022 -0300
    Add a check_reboot function
commit acce5e0cf809f3d3145f7780648c1ac2f136a3a4
Author: AlexFidalgo <alexfidalgo10@gmail.com>
Date:   Fri Jul 1 10:43:29 2022 -0300
    Create an empty all_checks.py
    
$ git config -l
diff.astextplain.textconv=astextplain
filter.lfs.clean=git-lfs clean -- %f
filter.lfs.smudge=git-lfs smudge -- %f
filter.lfs.process=git-lfs filter-process
filter.lfs.required=true
http.sslbackend=openssl
http.sslcainfo=C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt
core.autocrlf=true
core.fscache=true
core.symlinks=false
pull.rebase=false
credential.helper=manager-core
credential.https://dev.azure.com.usehttppath=true
init.defaultbranch=master
core.editor=nano
user.email=alexfidalgo10@gmail.com
user.name=AlexFidalgo
core.repositoryformatversion=0
core.filemode=false
core.bare=false
core.logallrefupdates=true
core.symlinks=false
core.ignorecase=true

If you've already run git init on a project directory containing a .git subdirectory, you can safely run git init again on the same project directory. The operation 
is what we call idempotent; running it again doesn't override an existing .git configuration.

git add README
This command adds changes from the working tree to the staging area i.e., it gathers and prepares files for Git before committing them. In other words, it updates 
the index with the current content found in the working tree to prepare the content that's staged for the next commit. However, git add doesn't affect the repository 
in any serious way because changes are not actually recorded until you commit them.

git diff README
You can see the differences between the older file and the new file. New additions are denoted by green-colored text and a + sign at the start of the line. Any 
replacements/removal are denoted by text in red-colored text and a - sign at the start of the line.

Skipping the Staging Area: we do this by using the dash a-flag to the git commit command; this flag automatically stages every file that's tracked and modified
before doing the commit letting us skip the git add command. Git commit -a doesn't work on new files because those are untracked.
git commit -a: shortcut to stage any changes to tracked files and commit them in one step. If the modified file has never been commited to the repo, we'll still
need to use git add to track it first

$ git commit -a -m "Call check_reboot from main, exit with 1 on error"
$ git log
commit 1bfddc8b2a2d061b90bbffbd41205f0466db9a51 (HEAD -> master)
Author: AlexFidalgo <alexfidalgo10@gmail.com>
Date:   Wed Jul 6 10:01:42 2022 -0300
    Call check_reboot from main, exit with 1 on error

Git uses the HEAD alias to represent the currently checked-out snapshot of your project

$ git log -p (shows the actual lines where changes were made)

$ git show c665c407a0b62cc0de0cde953c6e12639546f648 (shows changes during a specific commit, use git log to find out the commit ids)

$ git log --stat

Now I've modified all_checks.py, but not commited yet
$ git diff (shows the changes)
If the change was bigger and included several files, we could pass a file by parameter to see the differences relevant to that specific file, instead of all the
files at the same time
git add -p (lets us review changes before adding them; git will show us the change being added and ask us if we want to stage it or not) 
$ git add -p
$ git diff --staged
diff --git a/all_checks.py b/all_checks.py
index 5131528..25f2cb4 100644
--- a/all_checks.py
+++ b/all_checks.py
@@ -8,10 +8,11 @@ def check_reboot():
        return os.path.exist("/run/reboot-required")
 def main():
+       print("Program initiated")
        if check_reboot():
                print("Pending Reboot")
                sys.exit(1)
        else:
                print("No Reboot Pending")
-               sys.exit(0)O
+               sys.exit(0)
 main()



 

























