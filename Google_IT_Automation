************** USING PYTHON TO INTERACT WITH THE OPERATING SYSTEM **************

cat: command that shows the contents of a file
python3 hello_world.py: executes file
nano hello_world.py: edit file
shebang line: #!/usr/bin/env python3 (we add this line on top of the file (from nano) to tell the OS  what command we want to use to execute that script)
#!/usr/bin/env python3 uses the operating system env command, which locates and executes Python by searching the PATH environment variable. Unlike Windows, the Python 
interpreter is usually already in the $PATH variable on linux, so you don't have to add it.

To run our file directly, we want it to be executable; so we need: 
chmod +x hello_world.py 
Now we can run the file by just prefixing it with a dot slash
./hello_world.py
We need the ./ because the script isn't located in any of the directories listed in the path variable. This variable tells the OS where to find executables. The dot 
represents the current directory (find the script in the current directory and execute it)

vim, atom: linux text editors that have syntax highlighting

The shutil module offers a number of high-level operations on files and collections of files. In particular, it provides functions that support file copying and removal.
isk_usage() method is used to get disk usage statistics of the given path. This method returns a named tuple with the attributes total, used, and free. The total attribute 
represents the total amount of space, the used attribute represents the amount of used space, and the free attribute represents the amount of available space, in bytes.
psutil (Python system and process utilities) is a cross-platform library for retrieving information on the processes currently running and system utilization (CPU, memory, 
disks, network, sensors) in Python.
psutil.cpu_percent() returns a float showing the current system-wide CPU use as a percentage.

Requests is a Python module that you can use to send all kinds of HTTP requests. Features range from passing parameters in URLs to sending custom headers and SSL verification.
A request is when you ping a website for information.
You can add headers, form data, multi-part files, and parameters with simple Python dictionaries.You can then access the response data using the same request.

Use nano editor to create a new file network.py: nano network.py
check_localhost checks whether the local host is correctly configured. We do this by calling the gethostbyname within the function.

#!/usr/bin/env python3
import requests
import socket
def check_localhost():
        localhost = socket.gethostbyname('localhost')
        if localhost == '127.0.0.1':
                return True
        return False
def check_connectivity():
        request = requests.get("http://www.google.com") #This returns the website's status code.
        if request.status_code() == 200:
                return True
        retrurn False

(Estou em um nano de outro python file) To import network module at the beginning of the file: from network import *

file = open("spider.txt")
print(file.readline()) #reads a single line of the file
print(file.read()) #reads the entire file
file.close()

with open("spider.txt") as file: #file is automatically closed after the with
        print(file.readline())
        
with open("spider.txt") as file:
        for line in file:
                print(line.upper())

with open("spider.txt") as file:
        for line in file:
                print(line.strip().upper())
                
file = open("spider.txt")
lines = file.readlines()
file.close()
lines.sort()
print(lines)

with open("novel.txt", "w") as file:
        file.write("It was a dark and stormy night")
        
If you open a file for writing and the file already exists, the old contents will be deleted as soon as the file is opened.

import os 
os.remove("novel.txt") #deletes file
os.rename("first_draft.txt", "finished_masterpiece.txt")
os.path("finished_masterpiece.txt") #returns whether the file exists or not
os.path.getsize("spider.txt")
os.path.getmtime("spider.txt") #returns when file was last modified (seconds since 1970)
import datetime
timestamp = os.path.getmtime("spider.txt")
datetime.datetime.fromtimestamp(timestamp)
os.path.abspath("spider.txt") #returns the absolut path

print(os.getcwd())
os.mkdir("new_dir")
os.chdir("new_dir") #move para o diretorio new_dir
os.mkdir("newer_dir")
os.rmdir("newer_dir") #deleta newer_dir
os.listdir("dir2") #lists all files in that directory
-> ['images', 'index.html', 'favicon.ico']

dir = "dir2"
for name in os.listdir(dir):
        fullname =os.path.join(dir, name)
        if os.path.isdir(fullname):
                print("{} is a directory".format(fullname))
        else:
                print("{} is a file".format(fullname))

import os
# current working directory
path = os.getcwd()
print("Current Directory:", path)
# parent directory
parent = os.path.join(path, os.pardir)
# prints parent directory
print("\nParent Directory:", os.path.abspath(parent))
Output:
                Current Directory: /home/geeks/Desktop/gfg
                Parent Directory: /home/geeks/Desktop

Parsing: analyzing a file's content to correctly structure the data

import csv
f = open("csv_file.txt")
csv_f = csv.reader(f) #The reader() function of the CSV module will interpret the file as a CSV.
for row in csv_f:
        name, phone, role = row
        print("Name: {}, Phone: {}, Role: {}".format(name, phone, role))
f.close()

hosts = [["workstation.local", "192.168.25.46"], ["webserver.cloud", "10.2.5.6"]]
with open('hosts.csv', 'w') as hosts_csv:
        writer = csv.writer(hosts_csv)
        writer.writerows(hosts)
        
with open('software.csv') as software:
        reader = csv.DictReader(software)
        for row in reader:
                print("{} has {} users".format(row["name"], row["users"]))

user = [{"name": "Sol Mansi", "username": "solm", "department": "IT infrastructure"}, {"name": "Lio Nelson", "username": "lion", "department": "Development"}]
keys = ["name", "username", "department"]
with open('by_department.csv', 'w') as by_department:
        writer = csv.DictWriter(by_department, fieldnames = keys)
        writer.writeheader()
        writer.writerows(users)

REGULAR EXPRESSIONS

log = "July 31 bad_process[12345]: ERROR"
index = log.index("[")
print(log[index + 1 : index + 6])

import re 
log = "July 31 bad_process[12345]: ERROR"
regex = r"\[(\d+)\]"
result = re.search(regex, log)
print(result[1])
12345

The grep command utilizes regular expressions on Linux, but is not a part of the standard re Python module.
GREP prints out any line that matches the query that we pass in in the file that we give it. Let's check if we find "thon" inside the /usr/share/dict/words file (this file 
contains one word per line)
~$ grep thon /usr/share/dict/words
This command is case sensitive. If we want to match either lower or uppercase words, we have to add the -i parameter
~$ grep -i python /usr/share/dict/words

A dot matches any character (wildcard)
~$ grep l.rts /usr/share/dict/words

The circumflex [^] and the dollar sign [$] are anchor characters. They match the start and end of a line
^ and $ tell us where in the line the regex should match from (works with the lines, not the individual words)
^: beggining
$: end
Look for all the words that start with string fruit in the file
~$ grep ^fruit /usr/share/dict/words
Loof for all the words that end with cat
~$ grep cat$ /usr/share/dict/words

~$ nano regex.txt
GNU nano 4.8
abacate
minha alma foi embora
abelha motor
meu erro foi este
etanol
azeite
as muitas horas tomando leite
as muitas horas comendo abacate
~$ grep ^a regex.txt
abacate
abelha
azeite
as muitas horas tomando leite
as muitas horas comendo abacate
~$ grep e$ regex.txt
abacate
meu erro foi este
azeite
as muitas horas tomando leite
as muitas horas comendo abacate
~$ grep -e ^a -e e$ regex.txt
abacate
abelha
meu erro foi este
azeite
as muitas horas tomando leite
as muitas horas comendo abacate

r indicates that we're dealing with a rawstring (the python interpreter shouldn't try to interpret any special characters, instead should just pass the string to the function
as is
import re 
result = re.search(r"aza", "plaza")
print(result)
<re.Match object; span=(2, 5), match='aza'>

print(re.search(r"^x", "xenon"))
<re.Match object; span=(0,1), match='x'>

print(re.search(r"p.ng", "penguin")
<re.Match object; span=(0,4), match='peng'>

def check_aei (text):
  result = re.search(r"a.e.i", text)
  return result != None
print(check_aei("academia")) # True
print(check_aei("aerial")) # False
print(check_aei("paramedic")) # True

print(re.search(r"p.ng", "Pangaea", re.IGNORECASE))
<re.Match object; span=(0,4), match='Pang'>

print(re.search(r"[Pp]ython", "python")) # will match both Python and python
<re.Match object; span=(0, 6), match='python'>

[a-z] will match any lowercase letter
print(re.search(r"[a-z]way", "The end of the highway"))
<re.Match object; span=(18, 22), match='hway'>
print(re.search(r"[a-z]way", "What a way to go"))
None

print(re.search(r"cloud[a-zA-Z0-9]", "cloudy"))
<re.Match object; span=(0, 6), match='cloudy'>
print(re.search(r"cloud[a-zA-Z0-9]", "cloud9"))
<re.Match object; span=(0, 6), match='cloud9'>
print(re.search(r"cloud[a-9]", "cloud9"))
error: bad character range a-9

[^] searches for characters that aren't in the group
print(re.search(r"[^a-zA-Z]", "This is a sentence with spaces."))
<re.Match object; span=(4, 5), match=' '>
print(re.search(r"[^a-zA-Z ]", "This is a sentence with spaces."))
<re.Match object; span=(30, 31), match='.'>

| alternative options
print(re.search(r"cat|dog", "I like cats."))
<re.Match object; span=(7, 10), match='cat'>

findall returns all matches, not just the first one like search

print(re.findall(r"cat|dog", "I like both dogs and cats."))
['dog', 'cat']

.* matches any character repeated as many times as possible, including zero
print(re.search(r"Py.*n", "Pygmalion"))
<re.Match object; span=(0, 9), match='Pygmalion'>
print(re.search(r"Py.*n", "Python programming")) #exhibits greedy behavior
<re.Match object; span=(0, 17), match='Python programmin'>
print(re.search(r"Py[a-z]*n", "Python programming"))
<re.Match object; span=(0, 6), match='Python'>

+ matches one or more occurrences of the character that comes before it
print(re.search(r"o+l+", "goldfish"))
<re.Match object; span=(1, 3), match='ol'>
print(re.search(r"o+l+", "goooooolllllldfish"))
<re.Match object; span=(1, 13), match='oooooollllll'>
print(re.search(r"o+l+", "boil"))
None

? matches either zero or one occurrence of the character before it
print(re.search(r"p?each", "To each their own")) #the p is optional
<re.Match object; span=(3, 7), match='each'>
print(re.search(r"p?each", "I like peaches"))
<re.Match object; span=(7, 12), match='peach'>














